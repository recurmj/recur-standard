# RIP-002: Authorization Registry & Events (Optional Index)

**Author:** M J 
**Status:** Draft  
**Created:** October 2025  
**Category:** Core — Optional Index  
**Layer:** Protocol / Interface  
**Depends on:** RIP-001 (Permissioned-Pull Standard)

---

## Abstract

RIP-002 defines a minimal, optional **Authorization Registry & Events** interface for the RIP-001 permissioned-pull model.  
Its purpose is to standardize **how authorizations are referenced and observed** (revocations, pulls, budgets) without forcing sensitive payloads on-chain.  
This enables wallets, explorers, and applications to present a **universal “Active Consents” view** and to index pull activity consistently across EVM networks.

RIP-002 is **not required** to use RIP-001. It is an **interoperability layer**: a canonical event schema and a narrow read/write surface for registries.

---

## Motivation

RIP-001 introduced *consented continuity* with an off-chain signed **Authorization** and an on-chain `pull()` that enforces scope, timing, and revocation.

Different implementations might:
- keep revocation bits and accounting **inside** a pull contract,
- or delegate them to a shared **external registry**,
- or mix both, emitting different events.

Without common events and a tiny read API, tooling becomes fragmented.

**RIP-002 solves this by standardizing:**
- a canonical **`authHash`** (the authorization identifier),
- **event names and topics** for pulls, revokes, and (optionally) budget updates,
- a narrow **registry interface** so wallets/indexers can check status and totals consistently.

It preserves privacy by **not requiring plaintext authorization fields** to be stored on-chain.

---

## Terminology

- **Authorization**: the RIP-001 signed payload granting consent to pull.  
- **`authHash`**: canonical identifier for an Authorization (see below).  
- **Registry**: any contract implementing the `IRecurAuthRegistry` interface herein.

---

## Canonical `authHash`

Implementations **must** derive `authHash` from the same field order as RIP-001 to ensure cross-tool consistency:

~~~
// Mirrors RIP-001 Authorization fields exactly (no signature, no domain)
authHash = keccak256(abi.encode(
    grantor,
    grantee,
    token,
    maxTotal,
    perPull,
    validAfter,
    validBefore,
    nonce
));
~~~

**Note:** authHash intentionally excludes the EIP-712 domain separator and signature bytes. It identifies the consent terms independent of verifying contract, enabling portable indexing.  

---


## Events (Canonical)





All RIP-001 pull contracts and RIP-002 registries **SHOULD** emit these events with identical names and indexed topics.



~~~
/// Emitted when a pull succeeds under a valid Authorization.
/// MAY be emitted by the pull contract and/or the registry.
///
/// index topics:
///   authHash (1), token (2), grantor (3)
event PullExecuted(
    bytes32 indexed authHash,
    address indexed token,
    address indexed grantor,
    address grantee,
    uint256 amount,
    uint256 cumulative  // total pulled under this auth after this event
);

/// Emitted when a grantor revokes an Authorization.
/// MUST be emitted by whichever component enforces revocation (contract or registry).
event AuthorizationRevoked(
    bytes32 indexed authHash,
    address indexed grantor,
    uint256 timestamp
);

/// Emitted when a maxTotal (budget) is updated for an Authorization
/// (only applicable if implementation supports mutable caps).
event AuthorizationBudgetUpdated(
    bytes32 indexed authHash,
    uint256 oldCap,
    uint256 newCap
);

/// Optional discovery hook: allows UIs to list consents without
/// revealing full payloads. Emitting is OPTIONAL.
event AuthorizationObserved(
    bytes32 indexed authHash,
    address indexed grantor,
    address indexed grantee,
    address token
);
~~~

### Rationale:


- PullExecuted aligns with RIP-001 but adds cumulative to simplify indexer state.
- AuthorizationRevoked timestamps revocation for deterministic UI ordering.
- AuthorizationBudgetUpdated covers adjustable caps (not required by RIP-001).
- AuthorizationObserved is a lightweight hint so UIs can discover consents without exposing amounts/timing fields.





---



## Registry Interface





An implementation **may** expose the following minimal interface.

Contracts that keep internal maps (like the RIP-001 reference) **SHOULD** mirror these semantics and emit the same events.


~~~
interface IRecurAuthRegistry {
    /// @notice Returns true if the authorization hash has been revoked.
    function isRevoked(bytes32 authHash) external view returns (bool);

    /// @notice Total amount pulled under this authorization hash so far.
    function pulledTotal(bytes32 authHash) external view returns (uint256);

    /// @notice Returns the configured cap (maxTotal) if tracked; 0 if unknown.
    function capOf(bytes32 authHash) external view returns (uint256);

    /// -------- Optional write surfaces (implementations MAY omit) --------

    /// @notice Record a pull for accounting. Should be called by the pull contract.
    /// MUST emit PullExecuted(authHash, token, grantor, grantee, amount, cumulative).
    function recordPull(
        bytes32 authHash,
        address token,
        address grantor,
        address grantee,
        uint256 amount
    ) external;

    /// @notice Revoke an authorization by hash. Only the grantor may revoke.
    /// MUST emit AuthorizationRevoked(authHash, grantor, timestamp).
    function revoke(bytes32 authHash) external;

    /// @notice Update the cap (maxTotal) tracked for an authorization.
    /// MUST emit AuthorizationBudgetUpdated(authHash, oldCap, newCap).
    function setCap(bytes32 authHash, uint256 newCap) external;

    /// @notice Optional discovery hook; allows UIs to find consents.
    /// SHOULD be grantor-only; emit AuthorizationObserved.
    function observe(bytes32 authHash, address grantee, address token) external;
}
~~~

**Notes:**



A registry can be **separate** from the pull contract (external index) or **embedded** (same address).
If separate, the pull contract **SHOULD** call recordPull(...) after successful transfers.
Registries **MUST NOT** require storing full Authorization fields; privacy remains default.





---



## Reference Behaviors





- **Revocation:** If both a pull contract and a registry track revocation, **either** being revoked MUST cause pull() to revert.
- **Accounting:** pulledTotal SHOULD include all amounts after the latest successful PullExecuted.
- **Cumulative:** When emitting PullExecuted, the cumulative argument SHOULD equal pulledTotal(authHash) after adding amount.




---




## Privacy Considerations





RIP-002 is designed to minimize leakage:



- No requirement to store maxTotal, perPull, timing fields, or signatures on-chain.
- AuthorizationObserved is optional; implementers may skip it for maximum privacy.
- UIs can reconstruct state **client-side** by hashing local Authorization copies and querying:
    - isRevoked(authHash), pulledTotal(authHash), and (if available) capOf(authHash).


---






## Security Considerations





- **Event Forgery:** Emitting standardized events does not replace actual checks. pull() MUST still enforce all RIP-001 validations.
- **Replay:** authHash uniqueness relies on nonce (RIP-001). Registries should treat each distinct authHash as a separate consent.
- **Revocation Authority:** revoke(authHash) MUST restrict caller to grantor.
- **Consistency:** If multiple contracts emit for the same authHash, indexers SHOULD reconcile by last-write-wins for cumulative, and boolean OR for revocation.









### Rationale





Why a **minimal** registry:



Many deployments will keep state inside the pull contract (simple, cheaper).
Some ecosystems will prefer a shared registry (easier indexing across many pull contracts).
A narrow, optional interface + common events lets both coexist while keeping wallets/tools consistent.




Why **authHash without domain/signature**:



The consent’s terms are what UIs need to track.
Keeping the identifier stable across verifying contracts enables portability and cross-app views.





---



## Backwards Compatibility





RIP-001 contracts are compatible as-is. They can implement/emit RIP-002 gradually.
Existing deployments that already emit PullExecuted SHOULD add the cumulative parameter, preserving topic order and names.





---



## Reference Implementation Notes





- A basic registry can be <200 LOC:
    - mapping(bytes32 => bool) revoked;
    - mapping(bytes32 => uint256) total;
    - optional mapping(bytes32 => uint256) cap;
- Pull contracts call recordPull(...) after successful transfer.
- UIs can compute authHash client-side (same field order as RIP-001) and query the registry/pull contract interchangeably.





---



## Suggested ABI (Solidity)



~~~

interface IRecurAuthRegistry {
    event PullExecuted(
        bytes32 indexed authHash,
        address indexed token,
        address indexed grantor,
        address grantee,
        uint256 amount,
        uint256 cumulative
    );

    event AuthorizationRevoked(
        bytes32 indexed authHash,
        address indexed grantor,
        uint256 timestamp
    );

    event AuthorizationBudgetUpdated(
        bytes32 indexed authHash,
        uint256 oldCap,
        uint256 newCap
    );

    event AuthorizationObserved(
        bytes32 indexed authHash,
        address indexed grantor,
        address indexed grantee,
        address token
    );

    function isRevoked(bytes32 authHash) external view returns (bool);
    function pulledTotal(bytes32 authHash) external view returns (uint256);
    function capOf(bytes32 authHash) external view returns (uint256);

    function recordPull(bytes32 authHash, address token, address grantor, address grantee, uint256 amount) external;
    function revoke(bytes32 authHash) external;
    function setCap(bytes32 authHash, uint256 newCap) external;
    function observe(bytes32 authHash, address grantee, address token) external;
}
~~~

---


## Deployment Patterns





- **Embedded Mode:** A RecurPull contract internally tracks revoked and pulledTotal and simply **emits RIP-002 events.**
- **External Mode:** A shared registry aggregates events from many RecurPull instances. Contracts call recordPull and UIs query the registry only.
- **Hybrid:** Keep enforcement locally for safety; mirror to registry for indexing.





---



## Test Vectors (Non-normative)





- **Simple Flow**
    - pull() transfers 25; contract emits PullExecuted(..., 25, cumulative=25).
    - Registry (if present) mirrors a recordPull and emits the same.

- **Revocation**
    - revoke(authHash) emits AuthorizationRevoked.
    - Subsequent pull() for that authHash MUST revert.


- **Cap Update (Optional)**
    - setCap(old=300, new=500) emits AuthorizationBudgetUpdated.
    - Future pull() cumulative may now exceed 300 up to 500.





---



## Copyright / License





© 2025 M J — Recur Labs

This document is released under the **Creative Commons Attribution 4.0 International (CC BY 4.0)** license.

Reference: *“RIP-002: Authorization Registry & Events (Optional Index), Recur Labs, 2025.”*

