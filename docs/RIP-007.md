# RIP-007: Programmatic Policy Objects for Permissioned Pull

**Author:** M J (Recur Labs)  
**Status:** Draft  
**Version:** 0.1  
**Date:** October 2025  
**Depends on:** RIP-001 (Permissioned Pull Object), RIP-002 (Consent Registry), RIP-005 (Flow Channels), RIP-006 (Universal Clock & Routing)  

---

## Abstract

RIP-007 defines **Programmatic Policy Objects**: machine-readable control layers that govern when and how a Permissioned Pull Object (PPO) may execute.  
A Policy Object can encode **spend ceilings, jurisdiction filters, KYC attestations, destination allowlists, rate guards, and emergency stops**; allowing institutions, treasuries, banks, or DAOs to enforce complex constraints *without manual intervention* and without introducing custody.

---

## Motivation

Large actors cannot distribute unlimited pull rights.  
They require **provable, enforceable boundaries**: the ability to show regulators, auditors, or governance systems that every pull remained within explicit, revocable consent.

Policy-augmented PPOs solve this by separating **authorization** from **governance logic**, keeping Recur non-custodial while still allowing fine-grained compliance controls.

---

## Specification (High-Level)

### 1. Policy Object

A `PolicyObject` binds:

- **who** may pull  
- **what** asset or token  
- **how much** per time window or epoch  
- **where** value may be routed (allowlisted receivers or domains)  
- **which compliance hooks** (e.g. KYC or risk-score attestations)  

Each Policy Object is **content-addressed** by its hash (`policyId`) and may live fully on-chain (simple) or off-chain (complex configs referenced by hash).

~~~solidity
struct PolicyObject {
    address grantor;
    address grantee;
    address token;
    uint256 maxPerEpoch;
    bytes32[] allowedDomains;
    bytes32 complianceRef;  // optional off-chain attestation / proof ref
    bool emergencyStop;
}
~~~

---

### 2. Policy Enforcer Contract

The **PolicyEnforcer** contract validates all pull or channel operations before execution.  
It acts as a programmable guard sitting in front of `pull()`, `accrue()`, or router logic.

~~~solidity
interface IPolicyEnforcer {
    function checkPolicy(
        bytes32 policyId,
        address grantor,
        address grantee,
        address receiver,
        uint256 amount,
        bytes32 domain
    ) external view returns (bool ok, string memory reason);
}
~~~

Rules:

- **Rejection precedence:** if `checkPolicy()` returns `false`, the underlying pull MUST revert.  
- **Revocation:** the Grantor can revoke or replace a policyId at any time.  
- **Auditability:** policy decisions and updates SHOULD emit canonical `PolicyChecked` and `PolicyRevoked` events.

---

### 3. Workflow

1. **Grantor defines** a policy configuration (`PolicyObject`).  
2. **PolicyEnforcer stores** it and returns a `policyId` (hash of the config).  
3. A **PPO or Flow Channel** references that `policyId`.  
4. Any `pull()` or routed flow MUST call `PolicyEnforcer.check()` before execution.  
5. If the check passes, execution proceeds normally under RIP-001 semantics.

~~~solidity
function pull(bytes32 policyId, PermissionedPullObject memory ppo, uint256 amount) external {
    (bool ok, ) = policyEnforcer.checkPolicy(
        policyId, ppo.grantor, ppo.grantee, ppo.receiver, amount, currentDomain()
    );
    require(ok, "policy violation");
    _executePull(ppo, amount);
}
~~~

---

## Revocation and Safety

- **Grantor control:** A grantor may revoke a policyId, causing all linked PPOs or channels to halt immediately.  
- **Emergency stops:** Setting `emergencyStop = true` in the Policy Object disables all execution paths instantly.  
- **Audit trail:** All decisions, updates, and revocations SHOULD be logged with standardized topics for verifiable audit trails.

---

## Compliance and Institutional Integration

Policies provide the bridge between **open protocols** and **regulated finance**.  
They enable:
- Treasury spending limits (daily, weekly, per-domain)  
- Jurisdiction-specific routing control  
- KYC-verified receivers only  
- Rate-guarded flow and epoch-based reporting  

Each of these remains **programmable**, **revocable**, and **non-custodial** — preserving self-custody while meeting institutional requirements.

---

## Reference Implementation

See `PolicyEnforcer.sol` and `PolicyObjectRegistry.sol`.  
They define minimal storage, enforcement, and event patterns for compliant permissioned-pull ecosystems.

---

## Narrative Line

RIP-007 turns consent into policy.  
This is where banks say “yes.”
