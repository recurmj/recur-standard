# RIP-001: The Permissioned-Pull Standard

**Status:** Final (v1.0 reference)  
**Type:** Standard Track — Core  
**Author:** M J (Recur Labs)  
**Created:** October 2025  
**Requires:** None  
**Replaces:** None  

---

### Abstract

RIP-001 defines the **Permissioned-Pull Standard**, a non-custodial mechanism for consented and continuous transfer of value.

Instead of waiting for ops to push funds after something goes wrong, an account (the **grantor**) can pre-authorize another party (the **grantee**) to pull funds under strict, cryptographically signed limits:
- who can pull,
- which token,
- how much per call,
- within which time window,
- and with the ability to revoke globally at any moment.

Transfers happen directly via `transferFrom(grantor → grantee)`.  
No pooled custody, no shared hot wallet, no bridge vault.  
We call this model **consented continuity**.

---

### Motivation

Finance today is reactive and push-based. Liquidity only moves *after* something is already on fire:
- market imbalance,
- exchange underfunded,
- desk can’t fill,
- L2 out of working capital.

That lag is operational risk.

RIP-001 flips the model: consent comes first, not last.  
The grantor signs an off-chain Authorization describing “you may pull this asset, up to this amount per call, only during this window.”  
The grantee can then execute pulls *within* that consent automatically, under enforcement, without re-asking permission every time.

This turns liquidity routing into an always-on, bounded, revocable utility — instead of panic transfers.

---

### Specification Summary

| **Element**              | **Description**                                                                                                     |
|--------------------------|---------------------------------------------------------------------------------------------------------------------|
| **Primitive**            | `pull()` — grantee-initiated, but fully scoped by grantor’s signed authorization.                                  |
| **Authorization Object** | EIP-712 typed data signed by the grantor, containing allowed grantee, token, per-call max, validity window, nonce. |
| **Revocation Mechanism** | A single registry call (`revoke`) permanently disables that Authorization hash for all future pulls.               |
| **Verification**         | ECDSA (EOA) or EIP-1271 (smart contract wallet) signature recovery over a domain-separated digest.                 |
| **Registry Tie-in**      | A Consent Registry tracks total pulled and revocation state for each Authorization hash.                           |
| **Compatibility**        | Works with standard ERC-20s. Grantor just needs to approve the executor contract as a spender.                     |

---

### Architecture Overview

**1. Entities**

- **Grantor**  
  The source of funds. Signs the Authorization.

- **Grantee**  
  The party allowed to call `pull()`. Must match the address named in the Authorization. Also the recipient of funds.

- **Executor Contract (e.g. `RecurPullSafeV2`)**  
  Stateless enforcer that:
  - checks signature,
  - enforces time window and `maxPerPull`,
  - ensures the Authorization hasn’t been revoked in the Consent Registry,
  - executes `transferFrom(grantor → grantee)`,
  - reports the pull to the registry.

  The executor **never** holds funds.

- **Consent Registry (e.g. `RecurConsentRegistry`)**  
  Global ledger that:
  - tracks how much has been pulled under a given Authorization hash (`authHash`),
  - binds that hash to the true grantor,
  - lets only that grantor revoke it for all future pulls,
  - emits canonical audit events.

---

**2. Flow**

1. Grantor signs a typed Authorization off-chain (EIP-712).  
2. Grantee calls `pull(auth, amount)` on the executor contract.  
3. Executor contract:
   - confirms `msg.sender` == `auth.grantee`,
   - checks time window `[validAfter, validBefore]`,
   - enforces `amount <= auth.maxPerPull`,
   - validates signature (EOA or EIP-1271 smart contract wallet),
   - asks the Consent Registry whether that Authorization hash is revoked,
   - executes `transferFrom(grantor → grantee)` directly,
   - tells the Consent Registry “this much was just pulled.”
4. Consent Registry updates totals and emits events.  
5. Grantor can revoke at any point at the registry. After revocation, future pulls under that Authorization hash fail everywhere.

---

**3. Consent Lifecycle**

**Authorize → Pull → Revoke**, fully machine-verifiable:

- Authorize = Grantor signs the Authorization.  
- Pull = Grantee calls `pull()` under those terms.  
- Revoke = Grantor calls `revoke()` in the Consent Registry.  
  After that, `pull()` reverts for that Authorization hash.

There is no “please stop” off-chain step. Revocation is global and immediate on-chain.

---

### Security & Revocation

- **Revocable by design**  
  The Consent Registry exposes `revoke(authHash)`.  
  Only the true grantor for that `authHash` can revoke.  
  After revoke, compliant executors MUST revert before moving funds.

- **Replay protection**  
  The Authorization includes a unique `nonce` and is signed as EIP-712 typed data where the domain includes:
  - `chainId`
  - `verifyingContract` (the specific deployed executor contract)

  That prevents replaying the same signature on another chain or on a malicious clone.

- **Granular scope**  
  The Authorization encodes:
  - exactly which grantee,
  - exactly which token,
  - exactly how much per call (`maxPerPull`),
  - exactly when it’s valid.

- **Visibility**  
  The Consent Registry’s `recordPull()` emits a canonical `PullExecuted` event with:
  - `authHash`
  - token
  - grantor
  - grantee
  - amount
  - updated running total

- **Non-custodial**  
  The executor never escrows funds. All movement is still direct `transferFrom(grantor → grantee)` using normal ERC-20 allowances.

---

### Reference Implementation Notes

The production reference for RIP-001 is `RecurPullSafeV2.sol`.  
The production reference for revocation + audit is `RecurConsentRegistry.sol`.

**Key behaviors in `RecurPullSafeV2.sol`:**

- `pull(auth, amount)` enforces:
  - `msg.sender == auth.grantee`
  - `block.timestamp` between `auth.validAfter` and `auth.validBefore`
  - `amount <= auth.maxPerPull`
  - Authorization not revoked (checked via registry `isRevoked(authHash)`)
  - signature is valid for `auth.grantor`

- Supports:
  - EOAs via standard ecrecover with strict (low-s) ECDSA rules,
  - smart contract wallets via `isValidSignature(...)` (EIP-1271).

- On success:
  - calls `IERC20(auth.token).transferFrom(auth.grantor, auth.grantee, amount)`
  - calls `registry.recordPull(...)`
  - emits `PullExecutedDirect(...)`

**Key behaviors in `RecurConsentRegistry.sol`:**

- On first `recordPull(authHash, ...)`, it permanently binds that `authHash` to the provided `grantor`.  
  Only that address can revoke.

- Tracks cumulative `totalPulled[authHash]`.

- Emits canonical events:
  - `PullExecuted(...)`
  - `AuthorizationRevoked(...)`
  - `AuthorizationBudgetUpdated(...)` (optional)

---

### Rationale

RIP-001 defines **motion under consent**, not new tokens.

It provides a safe primitive for:  
- automated market operations,  
- liquidity balancing across venues,  
- settlement routing under policy,  
- cross-domain movement (RIP-003 / RIP-004),  
- per-epoch spend ceilings (RIP-007).

This replaces “trusted ops” with verifiable, programmable policy.

---

### Backwards Compatibility

- Works with any ERC-20 supporting `transferFrom`.  
- Compatible with EOAs and EIP-1271 smart contract wallets.  
- No interference with contracts unaware of RIP-001.

---

### Copyright / Licensing / Attribution

© 2025 M J — Recur Labs  
This RIP text is licensed under **CC BY 4.0**, reference contracts under **Apache-2.0**.

Reference citation:  
“RIP-001: The Permissioned-Pull Standard.” Recur Labs, 2025.

---

### Appendix

**A. Production Authorization struct (`RecurPullSafeV2`)**

~~~solidity
struct Authorization {
    address grantor;
    address grantee;
    address token;
    uint256 maxPerPull;
    uint256 validAfter;
    uint256 validBefore;
    bytes32 nonce;
    bytes   signature;
}
~~~

**B. Production pull() call shape**

~~~solidity
function pull(
    Authorization calldata auth,
    uint256 amount
) external {
    // 1. caller must equal auth.grantee
    // 2. must be within [validAfter, validBefore]
    // 3. amount <= auth.maxPerPull
    // 4. registry.isRevoked(authHash) must be false
    // 5. signature must validate for auth.grantor (EOA or 1271)
    // 6. IERC20(auth.token).transferFrom(auth.grantor, auth.grantee, amount)
    // 7. registry.recordPull(...)
    // 8. emit PullExecutedDirect(...)
}
~~~

**End of RIP-001 (v1.0 final)**
