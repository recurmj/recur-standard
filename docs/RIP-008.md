# RIP-008: Settlement Mesh — Autonomous Liquidity Equilibrium

**Author:** M J — Recur Labs  
**Status:** Final (v1.0 reference)  
**Date:** October 2025  
**Category:** Coordination / Equilibrium Layer  
**Depends on:**  
- RIP-001 (Permissioned-Pull Standard)  
- RIP-002 (Consent Registry Interface)  
- RIP-003 (Cross-Network Flow Intent)  
- RIP-004 (Non-Custodial Rebalancing)  
- RIP-005 (Flow Channels)  
- RIP-006 (Universal Clock & Adaptive Routing)  
- RIP-007 (Policy Objects for Permissioned Pull)

---

## Abstract

RIP-008 defines the Settlement Mesh: a coordination layer that uses PPOs, Flow Channels, routing, and policy to maintain target liquidity distribution across multiple networks and venues; continuously and without custody.

In plain terms: liquidity self-balances across chains, exchanges, treasuries, custodians, etc. Systems don’t wait for failure and then react. They remain in balance as a standing condition.

---

## Motivation

Volatility cascades happen because liquidity sits in the wrong place until it’s too late. Traditional rebalancing is reactive: someone notices stress, then scrambles to move funds.

The Settlement Mesh continuously reallocates (via authorized pull) so systems enter stress already balanced, not after liquidation. The goal is proactive equilibrium: keep every domain near its target allocation at all times, under explicit consent, without introducing custody.

---

## Core Concepts

### Mesh Node

- A Mesh Node is an agent (on-chain contract plus optional off-chain executor) allowed to perform routed pulls.
- A Mesh Node operates only under:
  - RIP-006 timing (epoch / scheduling),
  - RIP-007 policy (caps, allowlists, compliance),
  - and active PPOs / Flow Channels (RIP-001, RIP-005).
- A Mesh Node does not “hold funds.” It is only allowed to trigger movement under consent.

### Target State

The Mesh continuously tries to maintain a desired allocation map across domains.

Example target distribution:

~~~
{
  "ChainA": "40%",
  "ChainB": "35%",
  "CustodianX": "25%"
}
~~~

Per domain, the Mesh can also track:
- targetBps / targetWeight (e.g. ChainA should hold 40% of total liquidity),
- risk thresholds or buffers,
- per-venue constraints (e.g. “CustodianX can never exceed 25%”).

### Loop

For each asset (e.g. USDC), over repeating epochs:

- Observe actual balances per domain.
- Compare vs target distribution.
- Identify underweight domains (deficit) and overweight domains (surplus).
- Issue routed pulls (not pushes) within policy constraints to correct drift.

High-level loop:

~~~
observe()   -> read balances + consent state
compare()   -> compute deviation vs targets
route()     -> choose which domain should receive funds
execute()   -> trigger authorized pull toward that destination
record()    -> emit events for audit / accounting
sleep()     -> wait for next epoch tick
~~~

Because pulls are within pre-signed, revocable PPOs, the Mesh never needs custody to enforce balance.

### Proof

Every movement is provably inside pre-granted consent:
- The Settlement Mesh can only instruct pulls that are authorized by a Permissioned Pull Object or Flow Channel.
- Revocation by the Grantor instantly disables further movement under that PPO or channel.
- Each executed pull is logged using the standardized event surface defined in RIP-002, so an auditor can replay and verify behavior.

---

## Security Model

- No custody  
  Mesh Nodes never hold pooled funds. They call authorized pull paths that move funds directly between approved sources and approved destinations.

- Hard stop  
  Any Grantor can revoke its PPO or Flow Channel. Once revoked, that liquidity source is immediately excluded from future balancing steps.

- Policy enforcement  
  Every routed pull must satisfy the active Policy Object (RIP-007). If policy says “do not send to Domain X,” routing must refuse to pull toward Domain X even if it is underweight.

- Timing discipline  
  The Mesh is driven by epochs from RIP-006 (Universal Clock). That prevents race conditions like “ChainA got drained too fast before ChainB could refill,” because accrual, routing, and pull execution are all evaluated on shared time slices.

---

## Reference Implementation

The reference implementation is split across multiple contracts/utilities:

- `SettlementMesh.sol`  
  - Stores target weights per destination.
  - Stores most recent observed balances per destination.
  - Chooses the most underweight destination.
  - Emits an instruction to route funds toward that destination.

- `AdaptiveRouter.sol`  
  - Given a deficit and a destination, selects a permissible source + path.
  - Calls the correct pull adapter (e.g. a contract that can call `pull()` under RIP-001 / RIP-005).
  - Enforces pause / revoke / cap before any movement.

- `DomainDirectory.sol`  
  - Maps logical “domains” (ChainA, ChainB, CustodianX, etc.) to concrete receivers / adapters.

- `UniversalClock.sol`  
  - Defines epochs for the Mesh to tick on, so reporting / routing are deterministic and auditable.

Example (conceptual) rebalance tick from `SettlementMesh.sol`:

~~~
/// Pseudocode sketch
function rebalanceTick(uint256 maxStepAmount) external onlyController {
    // 1. Compute total reported liquidity
    uint256 total = reportedTotal;

    // 2. Find the most underweight destination
    address deficitDomain;
    uint256 largestDeficit;
    for (each domain in destList) {
        uint256 want = (total * targetBps[domain]) / 10000;
        uint256 have = reportedBalance[domain];
        if (have < want) {
            uint256 deficit = want - have;
            if (deficit > largestDeficit) {
                largestDeficit = deficit;
                deficitDomain = domain;
            }
        }
    }

    // 3. Ask AdaptiveRouter to push funds toward that underweight domain
    if (deficitDomain != address(0) && largestDeficit > 0) {
        uint256 step = largestDeficit;
        if (step > maxStepAmount) {
            step = maxStepAmount;
        }
        router.routeStep(deficitDomain, step);
        emit MeshStep(deficitDomain, largestDeficit, step);
    }
}
~~~

This is continuous: the Mesh doesn’t wait for crisis. It nudges constantly.

---

## Compliance / Auditability

Settlement Mesh operation is auditable end-to-end:

- Every executed pull is already emitting `PullExecuted` (RIP-002).
- The Mesh itself SHOULD emit a high-level event for traceability, for example:

~~~
event MeshStep(
    address indexed destination,
    uint256 deficit,
    uint256 sent
);
~~~

- Auditors, custodians, and regulators can reconstruct:
  - which domain was underweight,
  - how much was authorized to be sent,
  - which consent / channel allowed it,
  - and whether that consent was still active and unrevoked at the moment of movement.

This creates an institutional comfort zone: provable liquidity discipline without pooled custody.

---

## Narrative Line

RIP-008 is continuous equilibrium for money.

Liquidity stops waiting to be rescued. It stays where it needs to be.

---

© 2025 Recur Labs — Part of the Recur Permissioned-Pull Standard (RIP Series 001–008)



